!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).fpc={})}(this,(function(e){"use strict";const t="boolean",r="function",n="number",o="object",i="string",s="symbol",l=e=>null===e?"null":typeof e!==n?typeof e:isNaN(e)?"NaN":isFinite(e)?n:"infinity",a=(e,t)=>{throw new TypeError(`Expected ${e}, got ${l(t)}`)},y=e=>Array.isArray(e),f=e=>typeof e===t,c=e=>typeof e===r,h=e=>c(e)?e:a(r,e),p=e=>Number.isSafeInteger(e),u=e=>p(e)?e:a("integer",e),g=e=>null!=e&&typeof e[Symbol.iterator]===r,m=e=>g(e)?e:a("iterable",e),w=e=>typeof e===n&&isFinite(e),E=e=>null!=e&&typeof e===o||typeof e===r,b=e=>E(e)?e:a(o,e),d=e=>null!=e&&typeof e.then===r,x=e=>d(e)?e:a("promise",e),O=e=>typeof e===i,S=e=>typeof e===s,v=(e,t)=>null==e?void 0:e[t],k=(e,t,r=[])=>r.length<t?(...n)=>k(e,t,r.concat(n)):e(...r),T=e=>{throw e&&O(e.stack)&&O(e.message)?e:new Error(e)},N={}.hasOwnProperty,A=e=>e,j={},I="object"==typeof console?(...e)=>(console.log(...e),e[0]):A;function P(e){for(const t in e)this[t]=e[t]}P.prototype={get(e){throw e instanceof Error?e:new Error("Trying to get value of Nothing")},getOrThrow(e){return this.get(e)},filter(e){return this.isEmpty||e(this.get())?this:F},map(e){return this.isEmpty?this:$(e(this.get()))},forEach(e){return this.isEmpty||e(this.get()),this},getOrElse(e){return this.nonEmpty?this.get():c(e)?e():e},orElse(e){return this.isEmpty?$(this.getOrElse(e)):this},toString(){return this.isEmpty?"":String(this.get())},*[Symbol.iterator](){this.nonEmpty&&(yield this.get())}};const F=new P({isEmpty:!0,nonEmpty:!1});function M(e){if(!(this instanceof M))return new M(e);this.get=()=>e}M.prototype=new P({isEmpty:!1,nonEmpty:!0});const $=e=>null==e?F:e instanceof $?e:new M(e);$.prototype=P.prototype;const B=e=>e;function _(e){for(const t in e)this[t]=e[t]}_.prototype={length:2,map(e){return this.isErr?this:z(e,this.get())},mapErr(e){return this.isOk?this:new L(e(this.getErr()))},forEach(e){return this.isErr||e(this.get()),this},forEachErr(e){return this.isOk||e(this.getErr()),this},merge(e=B,t=B){const r=this.mapErr(t).map(e);return r.isOk?r.get():r.getErr()},*[Symbol.iterator](){yield this.isOk?this.get():void 0,yield this.isErr?this.getErr():void 0}};const z=(e,...t)=>{h(e);try{const r=e(...t);return r instanceof z?r:new J(r)}catch(e){return e instanceof L?e:new L(e)}};function J(e){if(!(this instanceof J))return new J(e);this[0]=e,this.get=()=>e}function L(e){if(!(this instanceof L))return new L(e);this[1]=e,this.getErr=()=>e}z.promise=e=>x(e).then(J,L),z.prototype=_.prototype,J.prototype=new _({isOk:!0,isErr:!1,getErr:()=>{throw new Error("Trying to get error of Ok")}}),L.prototype=new _({isOk:!1,isErr:!0,get:()=>{throw new Error("Trying to get value of Err")}});const R={};function*W(e,t){let r=0;for(const n of e)t(n,r,e)&&(yield n),r++}function*q(e,t){let r=0;for(const n of e)t(n,r,e),yield n,r++}function*C(e,t){let r=0;for(const n of e)yield t(n,r,e),r++}function*D(e,t,r){let n=0;for(const o of e){if(n>=r)break;n>=t&&(yield o),n++}}class G{constructor(e,...t){h(e),this[Symbol.iterator]=t.length>0?()=>e(...t):e}filter(e){return new G(W,this,h(e))}forEach(e){return new G(q,this,h(e))}map(e){return new G(C,this,h(e))}reduce(e,...t){const[r]=t.length>0?t:[R];return((e,t,r)=>{const n=e[Symbol.iterator]();let o,i=0;if(r===R){const{done:e,value:t}=n.next();if(i++,e)throw new TypeError("reduce of empty stream with no initial value");o=t}else o=r;for(;;i++){const{done:r,value:s}=n.next();if(r)break;o=t(o,s,i,e)}return o})(this,h(e),r)}slice(e=0,t=1/0){if(u(e),t!==1/0&&u(t),e<0||t<0)throw new TypeError("Negative indexes cannot be used to slice streams");return new G(D,this,e,t)}consume(){return(e=>{for(const t of e);})(this)}toArray(){return Array.from(this)}}function*H(e){for(let t=0,r=e.length;t<r;t++)yield e[t]}function*K(e,t){let r=0,n=null==t?e(t,r++):t;for(;null!=n;)yield n,n=e(n,r++)}function*Q(e,t,r){let n=e;for(;n<=t;)yield n,n+=r}var U={fromArrayLike:e=>new G(H,(e=>{if(u(b(e).length)<0)throw new TypeError(`Expected non negative length, got ${e.length}`);return e})(e)),fromIterable:e=>(m(e),new G((()=>e[Symbol.iterator]()))),iterate:(e,t)=>new G(K,h(e),t),range:(e=0,t=1/0,r=1)=>new G(Q,e,t,r)};e.Err=L,e.Just=M,e.Maybe=$,e.Nothing=F,e.Ok=J,e.Result=z,e.Stream=U,e.bound=(e,t,r)=>Math.max(t,Math.min(r,e)),e.call=(e,t,...r)=>h(v(e,t)).apply(e,r),e.curry=(e,t=e.length)=>p(t)&&t>0?k(h(e),t):T(new TypeError(`Expected positive integer, got ${t}`)),e.deferred=()=>{let e,t;return{promise:new Promise(((r,n)=>(e=r,t=n))),resolve:e,reject:t}},e.delay=(e,t=0)=>(h(e),new Promise(((r,n)=>setTimeout((()=>e(r,n)),t)))),e.expectArray=e=>y(e)?e:a("array",e),e.expectBoolean=e=>f(e)?e:a(t,e),e.expectFunction=h,e.expectInteger=u,e.expectIterable=m,e.expectNumber=e=>w(e)?e:a(n,e),e.expectObject=b,e.expectPromise=x,e.expectString=e=>O(e)?e:a(i,e),e.expectSymbol=e=>S(e)?e:a(s,e),e.failWith=T,e.first=([e])=>e,e.flip=e=>(h(e),(...t)=>e(...t.reverse())),e.hasOwnProperty=(e,t)=>null!=e&&N.call(e,t),e.identity=A,e.isArray=y,e.isBoolean=f,e.isFunction=c,e.isInteger=p,e.isIterable=g,e.isNumber=w,e.isObject=E,e.isPromise=d,e.isString=O,e.isSymbol=S,e.last=([...e])=>e[e.length-1],e.lazy=(e,...t)=>{h(e);let r=j;const n=()=>r===j?n.update():r;return n.update=()=>r=e(...t),n},e.log=I,e.maybeArray=e=>y(e)?new M(e):F,e.maybeBoolean=e=>f(e)?new M(e):F,e.maybeFunction=e=>c(e)?new M(e):F,e.maybeInteger=e=>p(e)?new M(e):F,e.maybeIterable=e=>g(e)?new M(e):F,e.maybeNumber=e=>w(e)?new M(e):F,e.maybeObject=e=>E(e)?new M(e):F,e.maybePromise=e=>d(e)?new M(e):F,e.maybeString=e=>O(e)?new M(e):F,e.maybeSymbol=e=>S(e)?new M(e):F,e.negate=e=>(h(e),(...t)=>!e(...t)),e.prop=v,e.range=(e,t,r=1)=>Array(1+Math.floor((t-e)/r)).fill(0).map(((t,n)=>n*r+e)),e.second=([e,t])=>t,e.typeOf=l,Object.defineProperty(e,"__esModule",{value:!0})}));
