!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).fpc={})}(this,(function(e){"use strict";const t="boolean",r="function",n="number",o="object",i="string",s="symbol",l=e=>null===e?"null":typeof e!==n?typeof e:isNaN(e)?"NaN":isFinite(e)?n:"infinity",a=(e,t)=>{throw new TypeError(`Expected ${e}, got ${l(t)}`)},c=e=>Array.isArray(e),y=e=>typeof e===t,f=e=>typeof e===r,h=e=>f(e)?e:a(r,e),p=e=>Number.isSafeInteger(e),u=e=>p(e)?e:a("integer",e),g=e=>null!=e&&typeof e[Symbol.iterator]===r,m=e=>g(e)?e:a("iterable",e),w=e=>typeof e===n&&isFinite(e),b=e=>null!=e&&typeof e===o||typeof e===r,E=e=>b(e)?e:a(o,e),d=e=>null!=e&&typeof e.then===r,x=e=>d(e)?e:a("promise",e),v=e=>typeof e===i,O=e=>typeof e===s,k=(e,t)=>null==e?void 0:e[t],S=(e,t,r=[])=>r.length<t?(...n)=>S(e,t,r.concat(n)):e(...r),T=e=>{throw e&&v(e.stack)&&v(e.message)?e:new Error(e)},N={}.hasOwnProperty,A=e=>e,j={},I="object"==typeof console?(...e)=>(console.log(...e),e[0]):A;function P(e){for(const t in e)this[t]=e[t]}P.prototype={get(e){throw e instanceof Error?e:new Error("Trying to get value of Nothing")},getOrThrow(e){return this.get(e)},filter(e){return this.isEmpty||e(this.get())?this:F},map(e){return this.isEmpty?this:B(e(this.get()))},forEach(e){return this.isEmpty||e(this.get()),this},getOrElse(e){return this.nonEmpty?this.get():f(e)?e():e},orElse(e){return this.isEmpty?B(this.getOrElse(e)):this},toString(){return this.isEmpty?"":String(this.get())},*[Symbol.iterator](){this.nonEmpty&&(yield this.get())}};const F=new P({isEmpty:!0,nonEmpty:!1});function M(e){if(!(this instanceof M))return new M(e);this.get=()=>e}M.prototype=new P({isEmpty:!1,nonEmpty:!0});const B=e=>null==e?F:e instanceof B?e:new M(e);B.prototype=P.prototype;const $=e=>e;function _(e){for(const t in e)this[t]=e[t]}_.prototype={length:2,map(e){return this.isErr?this:z(e,this.get())},mapErr(e){return this.isOk?this:new L(e(this.getErr()))},forEach(e){return this.isErr||e(this.get()),this},forEachErr(e){return this.isOk||e(this.getErr()),this},merge(e=$,t=$){const r=this.mapErr(t).map(e);return r.isOk?r.get():r.getErr()},*[Symbol.iterator](){yield this.isOk?this.get():void 0,yield this.isErr?this.getErr():void 0}};const z=(e,...t)=>{h(e);try{const r=e(...t);return r instanceof z?r:new J(r)}catch(e){return e instanceof L?e:new L(e)}};function J(e){if(!(this instanceof J))return new J(e);this[0]=e,this.get=()=>e}function L(e){if(!(this instanceof L))return new L(e);this[1]=e,this.getErr=()=>e}z.promise=e=>x(e).then(J,L),z.prototype=_.prototype,J.prototype=new _({isOk:!0,isErr:!1,getErr:()=>{throw new Error("Trying to get error of Ok")}}),L.prototype=new _({isOk:!1,isErr:!0,get:()=>{throw new Error("Trying to get value of Err")}});const R={},W=e=>e[Symbol.iterator]();function*q(e,t){const r=W(e);for(let n=0;;n++){const{done:o,value:i}=r.next();if(o)break;t(i,n,e)&&(yield i)}}function*C(e,t){const r=W(e);for(let n=0;;n++){const{done:o,value:i}=r.next();if(o)break;t(i,n,e),yield i}}function*D(e,t){const r=W(e);for(let n=0;;n++){const{done:o,value:i}=r.next();if(o)break;yield t(i,n,e)}}function*G(e,t,r){const n=W(e);for(let e=0;;e++){const{done:o,value:i}=n.next();if(o||e>=r)break;e>=t&&(yield i)}}class H{constructor(e,...t){h(e),this[Symbol.iterator]=t.length>0?()=>e(...t):e}filter(e){return new H(q,this,h(e))}forEach(e){return new H(C,this,h(e))}map(e){return new H(D,this,h(e))}reduce(e,...t){const[r]=t.length>0?t:[R];return((e,t,r)=>{const n=W(e);let o,i=0;if(r===R){const{done:e,value:t}=n.next();if(i++,e)throw new TypeError("reduce of empty stream with no initial value");o=t}else o=r;for(;;i++){const{done:r,value:s}=n.next();if(r)break;o=t(o,s,i,e)}return o})(this,h(e),r)}slice(e=0,t=1/0){if(u(e),t!==1/0&&u(t),e<0||t<0)throw new TypeError("Negative indexes cannot be used to slice streams");return new H(G,this,e,t)}consume(){return(e=>{const t=W(e);for(;;){const{done:e}=t.next();if(e)break}})(this)}toArray(){return Array.from(this)}}function*K(e){for(let t=0,r=e.length;t<r;t++)yield e[t]}function*Q(e,t){let r=0,n=null==t?e(t,r++):t;for(;null!=n;)yield n,n=e(n,r++)}function*U(e,t,r){let n=e;for(;n<=t;)yield n,n+=r}var V={fromArrayLike:e=>new H(K,(e=>{if(u(E(e).length)<0)throw new TypeError("Expected non negative length, got "+e.length);return e})(e)),fromIterable:e=>(m(e),new H(()=>W(e))),iterate:(e,t)=>new H(Q,h(e),t),range:(e=0,t=1/0,r=1)=>new H(U,e,t,r)};e.Err=L,e.Just=M,e.Maybe=B,e.Nothing=F,e.Ok=J,e.Result=z,e.Stream=V,e.bound=(e,t,r)=>Math.max(t,Math.min(r,e)),e.call=(e,t,...r)=>h(k(e,t)).apply(e,r),e.curry=(e,t=e.length)=>p(t)&&t>0?S(h(e),t):T(new TypeError("Expected positive integer, got "+t)),e.deferred=()=>{let e,t;return{promise:new Promise((r,n)=>(e=r,t=n)),resolve:e,reject:t}},e.delay=(e,t=0)=>(h(e),new Promise((r,n)=>setTimeout(()=>e(r,n),t))),e.expectArray=e=>c(e)?e:a("array",e),e.expectBoolean=e=>y(e)?e:a(t,e),e.expectFunction=h,e.expectInteger=u,e.expectIterable=m,e.expectNumber=e=>w(e)?e:a(n,e),e.expectObject=E,e.expectPromise=x,e.expectString=e=>v(e)?e:a(i,e),e.expectSymbol=e=>O(e)?e:a(s,e),e.failWith=T,e.first=([e])=>e,e.flip=e=>(h(e),(...t)=>e(...t.reverse())),e.hasOwnProperty=(e,t)=>null!=e&&N.call(e,t),e.identity=A,e.isArray=c,e.isBoolean=y,e.isFunction=f,e.isInteger=p,e.isIterable=g,e.isNumber=w,e.isObject=b,e.isPromise=d,e.isString=v,e.isSymbol=O,e.last=([...e])=>e[e.length-1],e.lazy=(e,...t)=>{h(e);let r=j;const n=()=>r===j?n.update():r;return n.update=()=>r=e(...t),n},e.log=I,e.maybeArray=e=>c(e)?new M(e):F,e.maybeBoolean=e=>y(e)?new M(e):F,e.maybeFunction=e=>f(e)?new M(e):F,e.maybeInteger=e=>p(e)?new M(e):F,e.maybeIterable=e=>g(e)?new M(e):F,e.maybeNumber=e=>w(e)?new M(e):F,e.maybeObject=e=>b(e)?new M(e):F,e.maybePromise=e=>d(e)?new M(e):F,e.maybeString=e=>v(e)?new M(e):F,e.maybeSymbol=e=>O(e)?new M(e):F,e.negate=e=>(h(e),(...t)=>!e(...t)),e.prop=k,e.range=(e,t,r=1)=>Array(1+Math.floor((t-e)/r)).fill(0).map((t,n)=>n*r+e),e.second=([e,t])=>t,e.typeOf=l,Object.defineProperty(e,"__esModule",{value:!0})}));
